package generators

import (
	_ "embed"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"slices"
	"strings"
	"text/template"

	"github.com/fireland15/rpc-gen/internal/model"
	"github.com/iancoleman/strcase"
)

type GoServerConfig struct {
	Output  string `json:"output"`
	Package string `json:"package"`
	Types   map[string]struct {
		Package   string `json:"package"`
		Namespace string `json:"namespace"`
		TypeName  string `json:"typeName"`
	} `json:"types"`
}

type GoEchoServerGenerator struct {
	config   GoServerConfig
	template *template.Template
}

//go:embed go_echo_server.tmpl
var go_server_template string

func NewGoEchoServerGenerator(config json.RawMessage) (CodeGenerator, error) {
	if config == nil {
		panic("config is nil")
	}

	c := new(GoEchoServerGenerator)

	err := json.Unmarshal(config, &c.config)
	if err != nil {
		return nil, err
	}

	funcs := make(template.FuncMap, 0)
	funcs["toCamel"] = strcase.ToCamel
	funcs["toLowerCamel"] = strcase.ToLowerCamel
	funcs["toSignature"] = func(m model.Method) string {
		params := make([]string, len(m.Parameters))
		for idx, p := range m.Parameters {
			params[idx] = fmt.Sprintf("%s %s", p.Name, c.resolveType(p.Type))
		}

		returnType := "error"
		if m.ReturnType != nil {
			returnType = fmt.Sprintf("(%s, error)", c.resolveType(*m.ReturnType))
		}

		return fmt.Sprintf("%s(%s) %s", m.Name, strings.Join(params, ", "), returnType)
	}
	funcs["joinParameters"] = func(m model.Method) string {
		params := make([]string, len(m.Parameters))
		for idx, p := range m.Parameters {
			params[idx] = fmt.Sprintf("params.%s", strcase.ToCamel(p.Name))
		}
		return strings.Join(params, ", ")
	}
	funcs["hasParameters"] = func(m model.Method) bool {
		return len(m.Parameters) > 0
	}
	funcs["hasReturnValue"] = func(m model.Method) bool {
		return m.ReturnType != nil
	}
	funcs["resolveType"] = c.resolveType

	tmpl, err := template.New("go-echo").Funcs(funcs).Parse(go_server_template)
	if err != nil {
		return nil, err
	}

	c.template = tmpl
	return c, nil
}

func (g *GoEchoServerGenerator) resolveType(typeName model.Type) string {
	if typeName.Variant == model.TypeVariantNamed {
		typeConfig, found := g.config.Types[typeName.Name]
		if !found {
			return typeName.Name
		}
		return fmt.Sprintf("%s.%s", typeConfig.Namespace, typeConfig.TypeName)
	} else if typeName.Variant == model.TypeVariantOptional {
		inner := g.resolveType(*typeName.Inner)
		return fmt.Sprintf("*%s", inner)
	} else if typeName.Variant == model.TypeVariantArray {
		inner := g.resolveType(*typeName.Inner)
		return fmt.Sprintf("[]%s", inner)
	} else {
		panic("unreachable")
	}
}

func (g *GoEchoServerGenerator) Generate(service *model.ServiceDefinition) error {
	err := os.MkdirAll(filepath.Dir(g.config.Output), os.ModePerm)
	if err != nil {
		return err
	}

	f, err := os.Create(g.config.Output)
	if err != nil {
		err = fmt.Errorf("problem opening '%s' (GoEchoServerGenerator): %w", g.config.Output, err)
		return err
	}
	defer f.Close()

	_, err = fmt.Fprintln(f, "// This file is autogenerated. Any changes will be overwritten when regenerated.")
	if err != nil {
		return err
	}

	_, err = fmt.Fprintf(f, "package %s\n\n", g.config.Package)
	if err != nil {
		return err
	}

	imports := make([]string, 0)
	for _, t := range g.config.Types {
		if !slices.Contains(imports, t.Package) {
			imports = append(imports, t.Package)
		}
	}

	err = g.template.ExecuteTemplate(f, "imports", imports)
	if err != nil {
		return err
	}

	for _, m := range service.Models {
		err = g.template.ExecuteTemplate(f, "model", m)
		if err != nil {
			return err
		}
	}

	err = g.template.ExecuteTemplate(f, "service_interface", service)
	if err != nil {
		return err
	}

	err = g.template.ExecuteTemplate(f, "handler", service)
	if err != nil {
		return err
	}

	for _, m := range service.Methods {
		err = g.template.ExecuteTemplate(f, "handler_func", m)
		if err != nil {
			return err
		}
	}

	return nil
}
